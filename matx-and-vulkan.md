# Vulkan + MaterialX
The goal here is a flexible way to load MaterialX shaders. The workflow is:

* Load MaterialX document
* Generate and Compile Shaders
* Find and load all textures (via MaterialX API)
* Use SPIRV Reflect to create the Descriptor Set Layout
  * Create UBOs and find parameter names
  * Use the parameter names with the MaterialX API to find their specified parameter values

_If you eliminate all the MaterialX bits then you're left with a generic framework that will build your descriptor sets and create required buffers for any shader._

## Compiling the MaterialX shader code
There's already some good examples on intializing and reading MaterialX documents here:
https://github.com/materialx/MaterialX/blob/master/documents/DeveloperGuide/CodeExamples.md

Then on shader generation here:
https://github.com/materialx/MaterialX/blob/master/documents/DeveloperGuide/ShaderGeneration.md

You can find a scrapbook example implementation of generating shaders here:
https://github.com/jerrans/matx-to-glsl/blob/master/main.cpp

This is using the Autodesk branch of MaterialX currently for building variables into layout blocks:
https://github.com/autodesk-forks/MaterialX/tree/adsk_contrib/dev

Once you have intialized MaterialX you want to find the appropriate nodes to generate shader from:
```
// generate shaders
MaterialX::GlslResourceBindingContextPtr bindCtx = std::make_shared<MaterialX::GlslResourceBindingContext>(0, 0);
generatorContext.pushUserData(MaterialX::HW::USER_DATA_BINDING_CONTEXT, bindCtx);

auto nodeGraph = doc->getNodeGraph(materialNodeName);
if (nodeGraph)
{
    MaterialX::TypedElementPtr outputShader = nodeGraph->getOutputs()[0];
    generateShaders(outputShader);
}
else {
    auto materialNodes = doc->getMaterialNodes();
    if (!materialNodes.empty())
    {
        for (const MaterialX::NodePtr& materialNode : materialNodes)
        {
            if (materialNode->getName() == materialNodeName)
            {
                std::unordered_set<MaterialX::NodePtr> shaderNodes = MaterialX::getShaderNodes(materialNode);
                if (!shaderNodes.empty())
                {
                    MaterialX::TypedElementPtr shaderNode = *shaderNodes.begin();
                    generateShaders(shaderNode);
                    break; // found one, all done
                }
            }
        }
    }
}
generatorContext.popUserData(MaterialX::HW::USER_DATA_BINDING_CONTEXT);
```

### Compilation
Next is to actually implement the `generateShaders` function.
Firstly `MaterialX::GlslShaderGenerator::generate` to generate the shader object, this provides a `MaterialX::ShaderPtr`, hang on to this for later.

Compiling with shaderc involves intializing the shaderc compiler, setting the auto bind/map parameters:

```
shaderc_compile_options_set_auto_bind_uniforms
```
```
shaderc_compile_options_set_auto_map_locations
```

#### Getting shader code for each shader stage
```
for (int i = 0; i < shader->numStages(); ++i)
{
    auto shaderStage = shader->getStage(i);
    shaderc_shader_kind shaderKind;
    if (shaderStage.getName() == "vertex")
        shaderKind = shaderc_shader_kind::shaderc_glsl_vertex_shader;
    else
        shaderKind = shaderc_shader_kind::shaderc_glsl_fragment_shader;
    auto sourceCode = shaderStage.getSourceCode();

    // compile
}
```

Then off you go with `shaderc_compile_into_spv`.

At this point you have all the information you need to create a `VkPipelineShaderStageCreateInfo` for each shader stage.

### Load Textures
Next step is to load any textures that the MaterialX document specifies are needed. I go through the shader stages and then through each uniform block to find any uniform that has a semantic type of `MaterialX::TypeDesc::SEMANTIC_FILENAME`.
I'm making an assumption that: firstly this is a texture, secondly that it is a path relative to the MaterialX base directory.

```
auto textureFile = uniform->getValue()->getValueString();
auto texture = LoadTextureFromImageFile(this->device, materialXBaseDir + "/" + textureFile, false);
```

Then I store this in a list of named textures that I can lookup later when writing the descriptors.

```
if (texture)
    this->namedTextures[variableName] = texture;
```

### Using reflection to create Descriptor Sets
This involves initializing SPIRV reflect with the shader code generated by shaderc and then iterating over the various kinds of resources.

```
std::vector<uint32_t> shaderCodeVector;
shaderCodeVector.assign(shaderCode, shaderCode + (shaderCodeSize/sizeof(uint32_t)));
spirv_cross::CompilerGLSL comp(std::move(shaderCodeVector));
spirv_cross::ShaderResources res = comp.get_shader_resources();
```

The goal here is to create a VkDescriptorSetLayoutBinding for each resource and then, at the end, create the VkDescriptorSetLayouts.
Maintaining this in a map is useful:
```
std::map< uint32_t /*descriptor set*/, std::vector<VkDescriptorSetLayoutBinding> >
```

At the end you just need to create a VkDescriptorSetLayoutCreateInfo with the set number and the vector of bindings attached.

Shader resources are grouped by type so you need to iterate over each group, for example finding the image samplers:

```
for (const spirv_cross::Resource& resource : res.sampled_images) // VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER
{
    auto set = comp.get_decoration(resource.id, spv::DecorationDescriptorSet);
    auto binding = comp.get_decoration(resource.id, spv::DecorationBinding);
    auto name = resource.name;
    // lookup texture by name in "namedTextures" map

    // create a VkDescriptorSetLayoutBinding for this resource and note which set it belongs to
}
```

This is done likewise for storage images, acceleration structures, storage buffers, etc... but for MaterialX we're only interested in sampled images and then uniform blocks. These are the biggest section and the important part of poking back into MaterialX to get the parameter values.

So it starts off the same.
```
for (const spirv_cross::Resource& resource : res.uniform_buffers) // VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER
{
    auto set = comp.get_decoration(resource.id, spv::DecorationDescriptorSet);
    auto binding = comp.get_decoration(resource.id, spv::DecorationBinding);
```

Next we've got enough information to create a buffer to store the uniform block data in:
```
    // create buffer for storing the data for this block
    auto uniformBufferData = this->device->CreateHostBuffer(VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT, VK_FORMAT_UNDEFINED);

    auto& type = comp.get_type(resource.base_type_id);
    uint32_t blockDataSize = comp.get_declared_struct_size(type);
    uint8_t* blockData = reinterpret_cast<uint8_t*>(malloc(static_cast<size_t>(blockDataSize)));
    std::shared_ptr<uint8_t> blockDataPtr(blockData, ::free); // hang on to this pointer in case we want to update uniform variables later
```

_Keeping that block data pointer means we can update the variables later._

Next step is to go through each member in the uniform block to get its size, offset and name. Then query MaterialX to get each member's value.

Finally I have an 'EditableParameter' struct that is used to maintain the connection between the parameter, the CPU memory data block, its offset _into_ that block and finally GPU buffer. This makes it easy to update/change those values later, for example for View parameters.
```
    unsigned member_count = type.member_types.size();
    for (unsigned i = 0; i < member_count; i++)
    {
        size_t member_size = comp.get_declared_struct_member_size(type, i);
        size_t offset = comp.type_struct_member_offset(type, i);
        auto memberName = comp.get_member_name(type.self, i);

        if (this->materialXShaderPtr)
            WriteMaterialXParameterValues(blockData + (size_t)offset, resource.name, memberName);

        EditableParameter editableParameter;
        editableParameter.buffer = uniformBufferData;
        editableParameter.bufferData = blockDataPtr;
        editableParameter.offset = offset;
        editableParameters[memberName] = editableParameter;
    }

    // write the block containing the parameter values to the uniform buffer
    uniformBufferData->Write(blockData, blockDataSize);

    // create a VkDescriptorSetLayoutBinding for this resource and note which set it belongs to
}
```

As in the sampled images example above we've now got enough information for the uniform buffer descriptor.

### Poking into MaterialX
The boilerplate for both querying parameter values and for loading textures is the same: for each shader stage, for each uniform block, for each variable in the uniform block. This is the same for the `WriteMaterialXParameterValues` referenced above and for the Load Textures function. I opted to separate these into 2 separate functions because for loading textures I just want to go through and find all the textures and load them.

```
auto& tokenSubstitutions = this->materialXShaderGenerator->getTokenSubstitutions();
for (int i = 0; i < this->materialXShaderPtr->numStages(); ++i)
{
    auto shaderStage = this->materialXShaderPtr->getStage(i);
    auto uniformBlocks = shaderStage.getUniformBlocks();
    for (auto& uniformBlock : uniformBlocks)
    {
        const auto& uniforms = uniformBlock.second;
        for (auto& uniform : uniforms->getVariableOrder())
        {
            auto variableName = uniform->getName();
            auto substitutedName = tokenSubstitutions.find(variableName);
            if (substitutedName != tokenSubstitutions.end())
                variableName = substitutedName->second;

            /////////////////////////////////////////////
            // Do work here
            /////////////////////////////////////////////
        }
    }
}
```

#### Load Textures
So in the case of loading textures it's just to check:
```
if( uniform->getType()->getSemantic() == MaterialX::TypeDesc::SEMANTIC_FILENAME )
```

Then follow the "Load Textures" above, get the filename, load the texture, etc...

#### Query Uniform Parameter Values
For querying uniform parameters (this is the implementation of `WriteMaterialXParameterValues` referenced above) the first thing is to get the base type, then get the parameter value(s) as strings. If it doesn't have a value then I'm just setting its values to 0, this is a good debugging point as something that doesn't have a value is something the application is required to provide (view params are an obvious example).
```
auto baseType = static_cast<MaterialX::TypeDesc::BaseType>(uniform->getType()->getBaseType());
if( uniform->getType()->getSemantic() != MaterialX::TypeDesc::SEMANTIC_FILENAME )
{
    std::vector<std::string> values;
    if (uniform->getValue())
        values = tokenize(uniform->getValue()->getValueString(), ",");
    else
        values = std::vector<std::string>(uniform->getType()->getSize(), "0");
}
```

At that point we've got the parameter values and they just need to be written to the data block, I pass the data block with the offset applied to the `WriteMaterialXParameterValues` function. So then the base type can be used to determine what we need to convert those string values to (really it's just int, float or bool), so std::atoi, std::atof and for a boolean the size is 4 bytes so a `values[i] == "true" ? 1u : 0u;` is fine.
Then just writing that into the data buffers and we're done.

_Note: Lights are a special case handled at the top of this function...for now_
```
    // TODO fix special case
    if (parameterBlockName == "LightData_pixel")
    {
        struct LightData {
            int type;
            float pad0;
            float pad1;
            float pad2;
        };
        std::vector<LightData> ld = { {0, 0.f, 0.f, 0.f}, {0, 0.f, 0.f, 0.f}, {0, 0.f, 0.f, 0.f} };
        memcpy(data, (void*)ld.data(), sizeof(LightData) * 3);
        return;
    }
    // end TODO
```

## Reflection for Vertex Attributes
You can use the same method to get the attribute and binding descriptions for your vertex data at the correct binding locations:

```
// where vertexAttributeMapping is a map of attribute names in MaterialX
// i.e. i_position, i_normal, i_tangent, i_texcoord0, etc... to a corresponding
// enum that can be used to retrieve the attribute desription from the input
// vertex data struct
spirv_cross::ShaderResources res = comp->get_shader_resources();
for (auto& inputResource : res.stage_inputs)
{
    auto it = vertexAttributeMapping.find(inputResource.name);
    if (it == vertexAttributeMapping.end())
        throw std::runtime_error("Unknown input attribute " + std::string(inputResource.name));

    assert(comp->has_decoration(inputResource.id, spv::DecorationLocation));
    auto location = comp->get_decoration(inputResource.id, spv::DecorationLocation);
    attributeDescriptions.push_back(VertexData::GetAttributeDescription(0, location, it->second));
}
bindingDescriptions.push_back(VertexData::GetBindingDescription(0));
```

This is an example of the VertexData struct I'm using.
```
// so the vertex data struct could look something like this
struct VertexData{
    glm::vec3 position;
    glm::vec3 normal;
    glm::vec4 tangent;
    glm::vec2 texcoord;

    static VkVertexInputBindingDescription GetBindingDescription(uint32_t binding)
    {
        VkVertexInputBindingDescription bindingDescription;
        bindingDescription.binding = binding;
        bindingDescription.stride = sizeof(Vertex);
        bindingDescription.inputRate = VK_VERTEX_INPUT_RATE_VERTEX;

        return bindingDescription;
    }

    static VkVertexInputAttributeDescription GetAttributeDescription(uint32_t binding, uint32_t location, VertexAttributeEnum attribute)
    {
        switch(attribute)
        {
            case VERTEX_ATTRIBUTE_POSITION: 
                return VkVertexInputAttributeDescription( { location, binding, VK_FORMAT_R32G32B32_SFLOAT, offsetof(VertexData, position) } );
            // etc...
        }
};
```
